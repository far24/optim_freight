# vehicle routing problem with cross-dock
# Wen et al. (2009)

#*****************************************
# Necessary Package
#*****************************************
using Random
using JuMP
using GLPK, Cbc
using LinearAlgebra
using CSV
using Distances

#*****************************************
# Network Property
#*****************************************
# suppliers are the pick-up nodes
P = [1,2]

# customers are the delivery nodes
C = [3,4]

# cross-docks
cd_pick_start = [C[end]+1]
cd_pick_end = [C[end]+2]
cd_del_start = [C[end]+3]
cd_del_end = [C[end]+4]

N = vcat(P,D, cd_pick_start, cd_pick_end, cd_del_start, cd_del_end)

# nodes in pickup Process
S = vcat(P, cd_pick_start, cd_pick_end)
D = vcat(C, cd_del_start, cd_del_end)

# vehicles
#K = [1,2]
K_S = [1,2]
K_D = [3,4]
# ****************************************
# parameters
#*****************************************
# number of pickup/delivery Nodes
n = length(P)

# Q = the vehicle capacity;
Q = 80

# location of nodes on a graph
#c = [9,5,4,8,13,11,8,8]

c = [10, 20, 65, 80, 55,55,55,55]
t_ij = pairwise(Euclidean(), c'; dims=2)
t_ij

# many-to-many relationship between supplier and customer
CV = [
1 1 0 0;
1 0 0 1;
0 1 1 0;
]

prod = [
20 30 0 0;
15 0 0 25;
0 25 25 0;
]

# total product supplied by supplier i
p_i = sum(prod, dims = 2)

# total demand of customer i
d_i = sum(prod, dims = 1)

#  TIME RELATED
# service time pickup location
sp_i = 10
# service time delivery location
sd_i = 10
# duration of unloading Process at CD
u = 5
# duration of loading Process at CD
l = 5
# maximum route duration
T = 99999

# very big number
M= 99999

# ****************************************
# Create a JuMP model
# ****************************************
cd_modl = Model(GLPK.Optimizer)

# ****************************************
# Decision variables
#*****************************************

# BINARY
# ^^^^^^^^^
# see Nikolopoulou et al. (2016)
@variable(cd_modl, x_ijk[i= S ,j= S,k=K_S], Bin)
@variable(cd_modl, z_hfl[h= D,f=D,l=K_D], Bin)
@variable(cd_modl, y_ik[i=S, k=K_S], Bin)
@variable(cd_modl, v_hl[i=D, k=K_D], Bin)

# CONTINUOUS
# ^^^^^^^^^^^^
# tp_ik :: Time at which vehicle k leaves pickup node i (i [ S, k [ KS)
# td_hl :: Time at which vehicle l leaves delivery node h (h [ D, l [ KD)
# RT_k :: Release time of pickup vehicle k at the cross-dock (k [ KS)
# DT_l :: Starting time of delivery vehicle l at the cross dock (l [ KD)
@variable(cd_modl, tp_ik[i=S, k=K_S] >=0)
@variable(cd_modl, td_hl[i=D, k=K_D] >=0)
@variable(cd_modl, RT_k[k=K_S] >=0)
@variable(cd_modl, DT_l[k=K_D] >=0)


# ****************************************
# Constraints
#*****************************************

# --------------------[Pick-up Process]-----------------------------------------
# Each node is visited once by one vehicle
@constraint(cd_modl, p_nd_visit[i= S, k=K_S],
                    sum(x_ijk[i,j,k] for j=S if i != j) == y_ik[i,k])

@constraint(cd_modl, p_one_veh[i= S],
                    sum(y_ik[i,k] for k=K_S) == 1)

# vehicle route starts from CD
@constraint(cd_modl, p_veh_start[i= cd_pick_start, k = K_S],
                    sum(x_ijk[i,j,k] for j=P) == 1)

# vehicle routes ends at CD
@constraint(cd_modl, p_veh_end[j= cd_pick_end, k = K_S],
                sum(x_ijk[i,j,k] for i=P) == 1)

# vehicle routes do not start from end points of CD
@constraint(cd_modl, p_veh_NOTstart[i= cd_pick_end, k = K_S],
                    sum(x_ijk[i,j,k] for j=P) == 0)


# vehicle routes do not end at start points of CD
@constraint(cd_modl, p_veh_NOTend[j= cd_pick_start, k = K_S],
                    sum(x_ijk[i,j,k] for i=P) == 0)

# flow conservation
@constraint(cd_modl, p_flow_cons[i= S, k = K_S],
                    sum(x_ijk[i,j,k] for j=S) == sum(x_ijk[j,i,k] for j=S)
                    )

# Capacity Constraints
@constraint(cd_modl, p_veh_cap[k=K_S],
                    sum(p_i[i] * y_ik[i,k] for i=P) <= Q)

# -----------[time constraints]
# time a pickup vehicle k arrives at pickup node j after visiting pickup node i
@constraint(cd_modl, p_veh_arr[i=S, j=S, k=K_S; i !=j],
                    tp_ik[i,k] + t_ij[i,j] + sp_i - tp_ik[j,k] - M*(1-x_ijk[i,j,k]) <= 0)

# Compute the departure time to zero if not visited
@constraint(cd_modl, p_init_dep_time[i=P, k=K_S],
                tp_ik[i,k] <= M*y_ik[i,k])



# --------------------[pickup --> delivery Connection]--------------------------#
# compute the release time of vehicle k at cross dock
@constraint(cd_modl, p_veh_arr_cd[i=P, j=cd_pick_end, k=K_S; i !=j],
                    tp_ik[i,k] + t_ij[i,j] + u - RT_k[k] - M*(1-x_ijk[i,j,k]) <= 0)

# release time of vehicle k at cross dock =0  if not visited
@constraint(cd_modl, init_veh_release[i= cd_pick_start, j= cd_pick_end, k=K_S],
                    RT_k[k] - M*(1-x_ijk[i,j,k]) <= 0)


@constraint(cd_modl, p_d_connect[i=P, k=K_S, h=C, l=K_D],
                    RT_k[k] <= CV[i,h-n]*DT_l[l] + M*(2-y_ik[i,k]-CV[i,h-n]*v_hl[h,l]))


# --------------------[delivery Process]----------------------------------------
# Each node is visited once by one vehicle
@constraint(cd_modl, d_nd_visit[h= D, l=K_D],
                    sum(z_hfl[h,f,l] for f=D if h != f) == v_hl[h,l])

@constraint(cd_modl, d_one_veh[h= D],
                    sum(v_hl[h,l] for l=K_D) == 1)


# vehicle route starts from CD
@constraint(cd_modl, d_veh_start[h= cd_del_start, l = K_D],
                    sum(z_hfl[h,f,l] for f=C) == 1)

# vehicle routes ends at CD
@constraint(cd_modl, d_veh_end[f= cd_del_end, l = K_D],
                sum(z_hfl[h,f,l] for h=C) == 1)

# vehicle routes do not start from end points of CD
@constraint(cd_modl, d_veh_NOTstart[h= cd_del_end, l = K_D],
                    sum(z_hfl[h,f,l] for f=C) == 0)

# vehicle routes do not end at start points of CD
@constraint(cd_modl, d_veh_NOTend[f= cd_del_start, l = K_D],
                    sum(z_hfl[h,f,l] for h=C) == 0)

# flow conservation
@constraint(cd_modl, d_flow_cons[h= D, l = K_D],
                    sum(z_hfl[h,f,l] for f=D) == sum(z_hfl[f,h,l] for f=D)
                    )
# Capacity Constraints
@constraint(cd_modl, d_veh_cap[l=K_D],
                sum(d_i[h-n] * v_hl[h,l] for h=C) <= Q)

# -----------[time constraints]
# time a pickup vehicle k arrives at pickup node j after visiting pickup node i
@constraint(cd_modl, d_veh_leave_cd[h=cd_del_start, f=D, l=K_D; h !=f],
                    DT_l[l] + l + t_ij[h,f]+ sd_i - td_hl[f,l] - M*(1- z_hfl[h,f,l])<= 0)


# release time of vehicle k at cross dock =0  if not visited
@constraint(cd_modl, init_veh_dep_cd[h= cd_del_start, f= cd_del_end, l=K_D],
                    DT_l[l] - M*(1-z_hfl[h,f,l]) <= 0)


@constraint(cd_modl, d_veh_arr[h=D, f=D, l=K_D; h !=f],
                    td_hl[h,l] + t_ij[h,f] + sd_i - td_hl[f,l] - M*(1- z_hfl[h,f,l]) <= 0)

@constraint(cd_modl, d_veh_arr_cd[h=C, f=cd_del_end, l=K_D; h !=f],
                    td_hl[h,l] + t_ij[h,f] - td_hl[f,l] - M*(1- z_hfl[h,f,l]) <= 0)

@constraint(cd_modl, time_hor[h=cd_del_end, l=K_D],
                    td_hl[h,l] <= T)

# Compute the departure time to zero if not visited
@constraint(cd_modl, d_init_dep_time[h=C, l=K_D],
                    td_hl[h,l] <= M*v_hl[h,l])


# ****************************************
# Objective
#*****************************************
@objective(cd_modl, Min,
sum(t_ij[i,j] * x_ijk[i,j,k] for i=S for j=S for k=K_S)
#    +sum(t_ij[h,f] * z_hfl[h,f,l] for h=D for f=D for l=K_D)
)


print("------------------------starting optimization--------------------------")
optimize!(cd_modl)


if termination_status(cd_modl) == MOI.OPTIMAL
    optimal_solution = value.(x_ijk)
    optimal_objective = objective_value(cd_modl)
elseif termination_status(cd_modl) == MOI.TIME_LIMIT && has_values(model)
    suboptimal_solution = value.(x_ijk)
    suboptimal_objective = objective_value(cd_modl)
else
    error("The model was not solved correctly.")
end




for k=K
    print("\nveh: ", k, "\t")
    for i= N
        for j=N
            if value.(x_ijk[i,j,k]) == 1
                print(i, "-->", j, "\t")
            end
        end
    end
end



for k=K
    print("\nveh: ", k)
    for i= N
        print("\tnode: ", i, "\t\t time: ", value.(s_ik[i,k]), "\n")
    end
end
